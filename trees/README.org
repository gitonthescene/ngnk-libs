* Some tree related routines

* Ramblings
  I hope to write up something more easily digestible but for now just doing a bit of a brain dump.

  Since K has nested vectors (lists) you could always represent trees in a Lisp-y way.  I.e.
  ~(root; ((leftchld; leaf); (rightchld; leaf)))~ where a node is ~(value; (children))~ and a leaf
  is somehow distinguishable from a non-leaf by being say an atom.

  There are some slightly annoying aspects to this, though.  For one, you need a convention to
  distinguish leaves from interior nodes.  For another to access interior nodes you need to descend
  the tree.  Sure, nine times out of ten when you're working with trees you're having to walk the
  tree, but still.  Lastly, nested lists mean pointers of pointers which just doesn't feel very
  array-like.

  What can be done?  Well there are [[https://github.com/JohnEarnest/ok/blob/gh-pages/docs/Trees.md][other representations of trees]], but the one I prefer is what I
  like to call an [[http://nsl.com/k/tableaux/trees.k][Apter tree]].  You can find examples on [[http://nsl.com][nsl.com]] or this article from
  [[http://archive.vector.org.uk/art10500340][Vector magazine]], but depending on your appetite this may not feel like enough of a description
  of how they work.

  [DISCLAIMER: I haven't done much(any?) research into the history of this data structure but I've
  also not run into anyone else who has.]

** Apter trees
   The basic idea is to separate the /structure/ of tree from its /contents/.  By "structure" we mean
   which nodes are connected to which other nodes.  While it might seem natural to do this with a
   dictionary of node -> list of children this brings us back to nested lists.  Here's where a neat
   observation comes in.

   : While each node can have multiple children, each node (except the root) has only /one/ parent.

   This if we have a tree such as ~(15;(12 9;18 2))~, then the parent of the leaf ~9~ is ~12~ and the parent
   of the ~12~ is ~15~.  Note that even here there's a bit of awkwardness.  Is ~12~ a node or is it a value?
   Similarly for ~9~.

   Let's give each node an index using a depth first preorder of the tree.  So we have 5 nodes whose
   indices are ~0 1 2 3 4~ and whose values are ~15 12 9 18 2~.  Now we can say that the parent of node
   ~2~ is ~1~ and the parent of node ~1~ is ~0~.  So using ~0N~ for the parent of the root (for now),
   the parent of each node is ~0N 0 1 0 3~.  Now we have a /"parent vector"/ and a /"values vector"/.
   If nothing else this clears up the confusion of which we're talking about.

   Note that there's nothing really special about using depth first preorder.  If we shuffled the indices,
   we'd simply need to shuffle the indices of each parent to point to its new location.  What /is/ important
   is that the parent vector and the values vector be in the /same order/.  Any ordering would faithfully
   represent the tree, but conventions are useful.

   Let's give these names ~p:0N 0 1 0 3~ and ~n:15 12 9 18 2~.  So the value of our node at index ~2~ is
   ~n[2]~9~ and its parent is at index ~p[2]~1~.  The value of the parent is ~n[p[2]]~12~ and the parent
   of the parent at index ~2~ is ~p[p[2]]~0~.  But we're using an array language!  We can do this across
   all the indices simultaneously. ~p[!#p]~0N 0 1 0 3~ and ~p[p[!#p]]~0N 0N 0 0N 0~.  This last could also
   be written ~2(p@)/!#p~.

   We could also look at the fixed point scan which gives a matrix whose columns give paths.

	:  (p@)\!#p
	: (0 1 2 3 4
	:  0N 0 1 0 3
	:  0N 0N 0 0N 0
	:  0N 0N 0N 0N 0N)

   from each index up to the /parent/ of the root, which is currently marked with ~0N~.  While this works
   well enough for many circumstances its more useful to stop at the root.  To make this happen we make
   the root /self-parenting/.  I.e. we define our parent vector to be ~p:0 0 1 0 3~.

	:  (p@)\!#p
	: (0 1 2 3 4
	:  0 0 1 0 3
	:  0 0 0 0 0)

*** Depth vectors
    Above we basically eyeballed the parent vector.  How do we generate a parent vector more generally?
	This of course depends on the information we're given, but often it's easiest to first shoot for a
	slightly different representation first.  That is a depth vector.

	The depth vector is simply the length of each path from a leaf up to the parent.

	I.e.

	 :  +/1&(p@)\!#p:0^p
	 : 0 1 2 1 2

	Generally it's easier to generate a depth vector than to directly generate a parent vector.  For
	instance ~d:{$[`i=@y;x;,/x,o[x+1]'y 1]}[0;(15;(12 9;18 2))]~ or ~+\-/"()"=\:"(a(bc(d)ef))"~.  (We'll
	talk more about this second in a bit.)

	Okay, let's assume depth vectors are easy to come by.  How does this help us create a parent vector?
	Here's where conventions help out.  If our depth vector is depth first preorder then we know that our
	parent is at the index /"closest to the left at depth one less than ours"/.  This is calculable!  There
	are different approaches to doing this calculation, but let's start with the easiest.

	:  {|/0,&x=-1+*|x}',\d
    : 0 0 1 0 3

   Okay so now let's say we have a parent vector and a node vector, what can we do with them?  Well, we
   can do things like ask which index is the parent of the node with value ~9~?  We can simply do ~p[n?9]~.
   Notice that we didn't have to walk the tree to find this!!

   But what if we did want to walk the tree?  That's still an option.  We just need to find children of
   each parent vector.  We can use "group" to do that ~=p~.  Here, having the root being self-parenting
   can be a bit of pain since we want to recurse to proper children and not enter an infinite loop.
   With simply trees like this we can just do =~0N,1_p~ to effectively make our parent a child of some
   /other node/ we'll never refer to.  There's also another little trick to get a useful prototype.
   Let's use ~chld:(=0N,1_p),(,0N)!,!0~ as our map from parents to children.  Then ~chld[0]~1 3~ and
   ~chld[2]~ is ~!0~.

   Now we can do the following to descend the tree:

   :  chld:(=0N,1_p),(,0N)!,!0
   :  {(x@z;o[x;y]'y@z)}[n;chld]0
   : (15
   :  ((12;,(9;()));(18;,(2;()))))

   (Here leaves have empty children, but this is simply an example of what's possible.)

* More ramblings to come...
