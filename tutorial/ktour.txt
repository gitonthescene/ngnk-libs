1 + 1     / basic arithematic can be done with infix notation
5 * 7
2 - 4
3 % 2     / division is done with % since / serves other purposes like the beginning of a comment!  :D
3 * 4 + 1       / evaluation happens from right to left.  There is no precedence between operations.
3 * (4 + 1)
(3 * 4) + 1     / Use parentheses when you want to control the order of evaluation
1 2 3 + 3 0 2   / rank polymorphism means these operations work for vectors of equal length
                / you get an error if these vectors are not equal length
1 + 3 0 2       / by scalar extension however, you can add scalars to vectors.
                / it's as if the scalar were repeated until the necessary length
# 9 8 4 5       / count counts the length of a vector
                / unlike the previous examples, # takes one argument.  single arguments are always taken to the right
2 4 , 9 0 4     / concat joins two vectors
# 2 4 , 9 0 4
#2 4,9 0 4      / spaces around built-in functions (called verbs in the lingo) are not necessary
                / but we'll use them here occasionally for a bit longer
,1              / enlist puts its argument in a list
                / this shows the meaning of "," is overloaded.  this happens a bunch in k, but often the meanings are related
# ,1            / this is a list of length 1
# 1             / hmm... scalars have length??  take this on faith for now that this comes in handy
@ 1             / @ returns the type of its argument, this is an "int".
                / oh, verbs which take one argument are called "monadic" and ones which take two "dyadic"
@ ,1            / this is a list of ints.  Capitals indicate lists. (lists, vectors, same thing)
,3 7 9          / You can enlist a list
# ,3 7 9        / this is a list of length 1
* 3 7 9         / this takes the "head" of the list.  i.e. the first element.
                / (not related to multiplication but another case of overloading)
*,3 7 9         / the head of an enlisted list is ... the list.  makes sense.
(,1 2 3),(,3 5 0)    / the concat of two enlisted lists to form a list of lists
(1 2 3;3 5 0)        / (Parens around semi-colon separated items form explicit lists)
#(,1 2 3),(,3 5 0)   / .. of length two
(,1 2 3), ,3 5 0     / the parentheses on the right are not necessary because of right-to-left evaluation
(0 1 3;99;6 1)       / explicit lists need not be uniform (neither length nor type)
@"string"            / strings are lists (capital C) of chars.
@"s"                 / a single char is also surrounded with double quotes. (this can be a bit confusing at first)
@,"s"                / to get a list of a single char, use enlist
("n";"i";"c";"e")    / double quotes are just syntactic sugar to make lists of chars.
"o","k"              / Oh yeah!  Concat can also concatenate two scalars
"s","tring"          / ... or a scalar to a vector.  Note that scalar extension does *not* apply here.
("o";,"k";4 9 2)     / An even more mixed array
#'("o";,"k";4 9 2)   / verbs can be modified to perform derived functionality
                     / here ' (called each) modifies count to perform count on each of the elements of its list argument
,'4 5 6              / each is called an adverb and can be applied to other verbs
                     / enlist each element of 4 5 6 to get a list of three one-element lists
3 9 2,'-1 -4 0       / each can be applied to dyadic verbs and pairs up the elements of both args
0,'3 4 1             / scalar extension applies to such pairing as well
0,/:3 4 1            / but there is a more explicit way to indicate that the left argument stays the same
                     / this adverb is called eachright
1 0,/:3 4 1          / It's useful when scalar extension doesn't apply
1 0,\:3 4 1          / There is an eachleft as well.
                     / Are we having fun yet??
                     / More verbs!
!8                   / enumerate numbers from 0 up to (but not including) 8
#!8
3#!8                 / "take" the first three number of this list
3_!8                 / "drop" the first three numbers of this list
-3#!8                / negative numbers to take from the back of the list
-3_!8
9=3                  / just plain equals.  true is 1 and false is 0.
3=3
4=!6                 / oho! scalar extension
0 1 2=!3             / and rank polymorphism!
0 1 2~!3              / match.  i.e. check that the whole vector is the same
(0;1 2 3)~(9=3;1+!3)  / even for mixed vectors
(0;1 2 3)=(9=3;1+!3)  / rank polymorphism applies to ragged shapes as well.  shapes must match (clearly)
3>4                   / plain old greater than
3<4
~3=3                  / monadic ~ is not
~3>4                  / less than or equal to is just not greater than.
~3>3
@7%3                  / oh, yeah.  floats are not ints
_7%3                  / floor strips off everything after the decimal point
@_7%3                 / .. and converts to ints
_7                    / floor of an int is fine
_"Hey, Dan!"          / lower case for strings.  (similar-ish..)
%25                   / monadic % is square root
-35                   / this is just an integer
-(4 8 5)              / this is the negate verb applied to a list
-4 8 5                / this is just a list of integers
-:4 8 5               / a colon forces this to be treated as a monadic function
                      / Notice that this monadic function applies to each element of the list unlike count (#)
                      / (colon has many more tricks up its sleeve...)
|-:4 8 5              / this is that list reversed
-4|8                  / maximum of -4 and 8 (clearly no relation to the monadic reverse above)
-4&8                  / minimum of -4 and 8
("abc";!3)            / the "matrix" made of the rows "abc" and !3.
                      / lists of lists of equal length can be thought of a matrices
+("abc";!3)           / flip!  The transpose of that matrix.  Again matrices must have rows of equal length.
("car";37;1 3 4)[0]   / this long and no mention of array indexing??
("car";37;1 3 4)[0 2] / indices can be lists
("car";37;1 3 4)[0 0] / lists can have repeats
1 4 9[2]              / no need for explicit list notation
1 4 9[(0;2 1;(,1;0))] / more generally, indices can be any shape
                      / the result matches the shape of the indices and picks out the values at the given index
1 4 9@(0;2 1;(,1;0))  / brackets are just syntactic sugar for the @ verb (called amend)
1 4 9[1 3]            / outdexing results in a null
^1 4 9[1 3]           / ^ tests for null
                      / More adverbs!
+/3 5 9               / slash as an adverb is "left fold" with the accumulator starting as the first element.
                      / Note here that the verb + is dyadic, but the modified verb +/ is used monadically
10+/3 5 9             / used dyadically, the left arg becomes the initial value for the accumulator
                      / slashes used as comments must be preceded with a space
                      / slashes used as adverbs must *not* be preceded by a space
|/-4 8 5              / this is "max over".  I.e. the fold of max over the list -4 8 5
|-4 8 5               / again, this is reverse
|:-4 8 5              / this forces | to be read as its monadic form
+\3 5 9               / the adverb scan is like fold, but produces all of its intermediate results
10+\3 5 9             / when using an explicit initial accumulator, the inital value is not part of the results
+':9 4 2              / pairs up each element of its list with the prior element and applies the verb. ': is called each-next.
                      / the first element is left as is
1+':9 4 2             / but you can supply a seed value to pair it with.
1-':9 4 2             / Note that the prior element becomes the right arg of the verb
                      / There are a couple of funky adverbs which modify non-verbs, which we'll call nouns
" "\"Yo yo yo"        / Split takes a string and splits the argument its given by it.
                      / Actually here it's technically taking the *character* " ", but that works too
"--"\"Yo--yo--yo"
" "/("Hey"; "you")    / Join takes an array of strings as its argument
10\12345              / Encode represents the given number as digits with the given base
2\13
10/9 8 7              / Decode calculates the value of a list of digits in the given base
2/1 0 1 1 0 1
24 60 60/1 2 3        / The base for each digit need not be the same
                      / Note that because of how this works, the top base is irrelevant, but needed to match the number of digits
-2 60 60/1 2 3
10 10\976             / For encode, if you supply a list of bases instead of a scalar,
                      / you always get as many digits as the length of that list
2 2 2 2 2\5
0 2 2 2\134           / If the top base is zero, it just returns whatever is left over after decoding the other digits
2/0 2 2 2\134
                      / Back to verbs for a bit...
8#1 2                 / Take can take more items than the list provided in which case it just cycles through
5#2                   / You can even give take a scalar to simply repeat the value
(5#2)\5               / Once again, parentheses are needed here because evaluation is from right-to-left
6 5#1 2               / You can even use a vector with take to generate lists of lists, one row at a time
                      / In this case it's often called "reshape" but the idea is the same
2 5_!10               / Drop with a vector becomes "cut".  The vector is split at the given indices and the first part is dropped.
0 3 7_!10             / To keep the first part, just make 0 the first element of the vector
&0 0 1 0 1 1          / Given a boolean list, where (&) gives the indices of the 1's
&1 0 2 3 0 4          / Actually, this is just a special case of "replicate" which generates a given number of repeats at the given index
                      / Here there is 1 zero, no ones, two twos, three threes, etc.
?&1 0 2 3 0 4         / Monadic ? (unique) only keeps the first occurence of each element in a list
? 7 8 2 3 7 1 3
7 8 2 3 7 1 3?1       / Dyadic ? (find) returns the index of the first occurence of the given element in a list
                      / Now things get a little tricky..
                      / Some verbs behave differently when given different types of arguments.
                      / This is kind of true with reshape and cut, but the behaviors weren't too different
                      / So this next may seem a bit random ...
15?3                  / Dyadic ? with an integer left argument is "roll".
                      / It generates that many random numbers from 0 to the right argument
15?"ace"              / If given a list as its right argument, it randomly picks elements from that list
-5?5                  / Deal is like roll only it doesn't repeat
                      / Phew!!  There's a lot here.  Grab a hot tea and let some of this sink in a bit.


                      / Feeling refreshed?  Let's introduce a few more types...
(1;"a";3%2)           / so far, we've seen ints, chars and floats
@'(1;"a";3%2)         / with scalar types `i, `c and `f
                      / Hmm...  What is `i?
@`i                   / A new type!  `s represents the symbol type
@`symbol              / Symbols are basically scalar strings.  In particular are used to represent types.
@"symbol"             / Remember vector types are represented with upper case letters.  This is a vector of `c elements.
#`symbol
#"symbol"
@`i`c`f               / Vectors of symbols can be represented by listing them one after another
                      / This is sometimes called "stranding".  Stranding is only possible for homogenous types
@1 2 3 5              / This is why vectors of integers can simply be listed one after another
@(`i;`c;`f)           / Of course explicit array notation is still possible
@@'(1;"a";3%2)
@'(1 2;"ab";3%2 1;`i`c)
1 0.3 2               / There is some magic here and there.  Here the ints are "promoted" to floats
1 2 3+4 5 6           / Also, it's worth explicitly noting that stranding binds tighter than any of the verbs
(1;2;3+4;5;6)         / This is something different.
1 2,(3+4),5 6         / You could also make this by building it up with the verb concat.
                      / The parentheses are necessary because of right to left evaluation
@(1;"a";3%2)          / Before we get too far away it's also worth noting that @ operates on the whole array
                      / This is a single type known as a "mixed array" and is represented by `A
@'(1;"a";3%2)         / "each" is needed to operate on each element
#'(1 2;"abcd";3%2 1;`i`c`s`A`C)  / similar to length
#(1 2;"abcd";3%2 1;`i`c`s`A`C)
                      / Over time you get used to which functions do this and which ones "permeate".
                      / i.e. operate on each element element naturally like + or *

                      / Let's introduce one more type: dictionaries
`a`b`c!3 4 5          / Dictionaries act like association lists and created with dyadic ! operating on two lists of equal length
!`a`b`c!3 4 5         / Monadic ! on a dictionary returns the keys of the dictionary
.`a`b`c!3 4 5         / Monadic . on a dictionary returns the values of the dictionary
(`a`b`c!3 4 5)[`b]    / Indexing can be used to extract the value associated with a given key

                      / It's probably best to start introducing some programming basics before moving on
d:`a`b`c!3 4 5        / : is used for assigning to a variable  (We told you colon had more tricks!)
d                     / See?  (This tutorial is running in a single session so this variable is still visible.)
d[`b]                 / That looks nicer.  We've extrated the value out of the dictionary d associated with the key `b
                      / It's probably worth noting that variables are not symbols and not strings.  They use no punctuation.
i123:1 2 3            / You can use numbers in the name but initial character must be a letter
i123[1]
i123@1                / Remember that you can use @ to index into an array
d@`c                  / Or even for looking up in a dictionary
i123 1                / You can also just list the two next to each other!  (This is *not* stranding!)
d`c                   / You don't even need a space when it's not ambiguous
i123:                 / Variables don't go away, but you can (re)assign them to "nothing" if you want to free memory
i:1 2 3               / Different variable
i 1                   / Here we need a space because i1 would be a(n undefined!) variable name.
d:`a`b`a!3 4 5        / Dictionaries can be weird.  You can repeat keys.
d`a                   / Only the first one is found with lookup
(!d;.d)               / But both original lists are still in the keys and values
                      / BTW, there is no "iter".  Keys and values must be extracted separately
+(!d;.d)              / Remember "flip"?  This gets the list of key/value pairs
(.d)(!d)?`a           / This is basically what dictionary lookups do...
(!d)?`a               / This extracts the keys and then uses "find" to find the index of the key
(.d)@(!d)?`a          / This extracts the values and uses the previously found index to index into the array
(.d)(!d)?`a           / But because there's no abmiguity (really!) you don't need the @ here.  It's not stranding so it's indexing.
                      / The parentheses are needed because of right to left evaluation.

                      / More programming basics ... and a new type!  lambdas!
f:{x}                 / Lambdas are formed with curly braces.  This takes a single arg (x) and returns it.
(f[1];f[`a];f[3%2])   / The lambda can be applied to arguments with brackets similar to array indexing
(f@1;f@`a;f@3%2)      / Or with @ ..
(f 1;f`a;f 3%2)       / Or even just juxtaposition ..
f'(1;`a;3&2)          / lambdas take adverbs just like verbs do
{x+y}[2;3]            / Brackets are (generally) necessary when supplying more than one arg
f                     / Also, lambdas don't have to be assigned to a variable the way f was
{x*y+z}[2;3;4]        / Functions can use up to three implicit arguments which have the names x, y and z
f:{x+y}[2]            / If fewer args are supplied than required, a "projection" is formed
@'({x};{x+y}[2])      / Projections are actually a different type, but this doesn't come up that often
f'3 4 5               / Projections basically "curry" the supplied argument
{[a;b;c;d]a+b*c-d}    / More than three arguments requires explicit argument declaration with brackets
{[x;y]x+y}[2;3]       / This can get noisy for simple stuff which is why implicit args exist
{2*y}[1;3]            / If you use an implicit y then the function takes (at least) two arguments, three if there is a z.
{2*y}[1]              / This is a projection
{2*y}[1]@6            / When called, passes the argument to y
f:+                   / BTW, verbs can be assigned to variables too
f[2;3]                / But in this form must use bracket indexing instead of infix notation
@f                    / Verbs have a different type as well
@f:@                  / Assignment can also happen inline.  This assigns f and then takes its type. (@ is also a verb!)
:[123;451]            / Colon is also a (dyadic) verb which returns its second argument.
                      / .. but is weird because it's hard to parse which of its various forms is meant in the code
:i:1 2 3              / Here it's used monadically(??) to return the value assigned to i
123:456               / Here it's used dyadically to return the right argument
:i:1 2 3              / This form is often useful when debugging code.



/ FIN
